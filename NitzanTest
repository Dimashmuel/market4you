/*
MAKE SURE THE FOLLOWING PATHS ALREADY EXIST IN THE SOURCE DESTINATION
Requried for the current build to work:
data\users\customers.csv
data\users\managers.csv
data\catalog.csv
*/

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

// CONSTS
#define LEGAL_AGE 16
#define MANAGER_CODE 1111
#define PHONE_NUM_LEN 10
#define MIN_PASSWORD_LEN 6

// FILES
#define PATH_CUSTOMERS "data\\users\\customers.csv"
#define PATH_MANAGERS "data\\users\\managers.csv"
#define PATH_CATALOG "data\\catalog.csv"
#define PATH_ORDERS_CONFIMRED "data\\orders\\unconfirmed\\"
#define PATH_ORDERS_UNCONFIRMED "data\\orders\\confirmed\\"

// FOLDERS
#define FOLDER_DATA "data"
#define FOLDER_DATA_USERS "data\\users"
#define FOLDER_DATA_ORDERS "data\\orders"
#define FOLDER_DATA_ORDERS_CONFIRMED "data\\orders\\confirmed"
#define FOLDER_DATA_ORDERS_UNCONFIRMED "data\\orders\\unconfirmed"

// Definitions
typedef enum { false, true } bool;
typedef enum { readId, readPassword, readName, readPhone } FieldUser;
typedef enum { productName, productCompany, productPrice, productQuantity, productCategory } FieldProduct;
typedef enum { none, customer, manager } UserType;

// Structs
typedef struct Details {
	char* name;
	char* id;
	char* password;
	char* phone;
} Details;
typedef struct Customer {
	Details details;
	char* age;
	int points;
} Customer;
typedef struct Manager {
	Details details;
} Manager;
typedef struct Product {
	char* name;
	char* company;
	char* quantity;
	char* price;
	char* category;
} Product;
typedef struct Order {
	Product* products;
	char* customerId;
	char* orderId;
	char* totalOrder;
} Order;
typedef struct Date {
	int day, month, year;
} Date;

/// <summary>
/// FUNCTION DECLARATIONS
/// </summary>

// String functions declarations
void overrideString(char** _str1, char* _str2);
void appendString(char** _str1, char* _str2);
void appendStringComma(char** _str1, char* _str2);
void appendStringNewLine(char** _str1, char* _str2);
void inputString(char* _str);
void printStr(char* _str);
void printStrLine(char* _str);
char* newString(int _size);
char* copyString(char* _str);


// File functions declarations
void writeFile(FILE* file, char* content);
void readFile(char* filename);
void writeCustomer(Customer* c);
void writeManager(Manager* c);
void create_folder(char* dirname);
void checkFolder();
void checkFiles();
char* readUser(char* filename, FieldUser field);
bool doesFileExists(char* filename);
FILE* openFile(char* filename, char* skipFormat);


// Authentication functions declarations
void registerCustomer(Customer* c);
void registerManager(Manager* m);
bool verifyName(Details* d);
bool verifyPassword(Details* d);
bool verifyId(Details* d, bool* flag, int regType);
bool verifyAge(Customer* c);
bool verifyPhone(Details* d);
bool TermsAndConditions();
UserType findUserType(char* id);
UserType loginUser();

// Catalog
void addProduct();
char* readProduct(char* filename, char* productName, char* _company, FieldProduct field);

// Welcome screen function declarations
void welcomeScreen();

/// <summary>
/// FUNCTION DEFINITIONS
/// </summary>

// String functions definitions
void overrideString(char** _str1, char* _str2) {
	char* str;
	str = malloc(sizeof(char) * strlen(_str2) + sizeof(char));
	if (str == NULL) exit(1);
	strcpy(str, _str2);
	free(*_str1);
	*_str1 = str;
}
void appendString(char** _str1, char* _str2) {
	char* str = malloc((strlen(*_str1) + strlen(_str2)) * sizeof(char) + sizeof(char));
	if (str == NULL) exit(1);
	strcpy(str, *_str1);
	strcat(str, _str2);
	free(*_str1);
	*_str1 = str;
}
void appendStringComma(char** _str1, char* _str2) {
	appendString(_str1, _str2);
	appendString(_str1, ",");
}
void appendStringNewLine(char** _str1, char* _str2) {
	appendString(_str1, _str2);
	appendString(_str1, "\n");
}
void inputString(char** _str) {
	char str[100];
	scanf_s("%s", str, 100);
	*_str = malloc(strlen(str) * sizeof(char) + sizeof(char));
	strcpy(*_str, str);
}
void printStr(char* _str) {
	printf("%s", _str);
}
void printStrLine(char* _str) {
	printf("%s\n", _str);
}
char* newString(int _size) {
	char* str;
	str = malloc(sizeof(char) * _size + sizeof(char));
	return str;
}
char* copyString(char* _str) {
	char* str;
	str = malloc(sizeof(char) * strlen(_str) + sizeof(char));
	if (str == NULL) exit(1);
	strcpy(str, _str);
	return str;
}
char* mergeStrings(char* _str1, char* _str2) {
	char* str;
	str = malloc(sizeof(char) * (strlen(_str1) + strlen(_str2)) + sizeof(char));
	if (str == NULL) exit(1);
	strcpy(str, _str1);
	strcat(str, _str2);
	return str;
}

// Files functions definitions
void writeFile(char* filename, char* content) {
	FILE* file;
	file = openFile(filename, "ab+", NULL);
	if (!file) {
		printStrLine("Error.");
		return;
	}
	fprintf(file, "%s", content);
	fclose(file);
}
void writeCustomer(Customer* c) {
	char* output = copyString("");
	appendStringComma(&output, c->details.name);
	appendStringComma(&output, c->details.id);
	appendStringComma(&output, c->details.password);
	appendStringComma(&output, c->age);
	appendStringNewLine(&output, c->details.phone);
	//appendStringNewLine(&output, c->points);
	writeFile(PATH_CUSTOMERS, output);
	free(output);
}
void writeManager(Manager* m) {
	char* output = copyString("");
	appendStringComma(&output, m->details.name);
	appendStringComma(&output, m->details.id);
	appendStringComma(&output, m->details.password);
	appendStringNewLine(&output, m->details.phone);
	writeFile(PATH_MANAGERS, output);
	free(output);
}
void create_folder(char* dirname) {
	int check;
	check = mkdir(dirname);
	if (check)
	{
		printf("Unable to create folder\n");
		exit(1);
	}
}
void checkFolder() //Create the defualts folders.
{
	if (!doesFileExists(FOLDER_DATA))
		create_folder(FOLDER_DATA);
	if (!doesFileExists(FOLDER_DATA_USERS))
		create_folder(FOLDER_DATA_USERS);
	if (!doesFileExists(FOLDER_DATA_ORDERS))
		create_folder(FOLDER_DATA_ORDERS);
	if (!doesFileExists(FOLDER_DATA_ORDERS_CONFIRMED))
		create_folder(FOLDER_DATA_ORDERS_CONFIRMED);
	if (!doesFileExists(FOLDER_DATA_ORDERS_UNCONFIRMED))
		create_folder(FOLDER_DATA_ORDERS_UNCONFIRMED);
}
void checkFiles() //Create the defualts files.
{
	if (!doesFileExists(PATH_CUSTOMERS))
		writeFile(PATH_CUSTOMERS, "Username,Identity,Password,Age,Points,Phone\n");
	if (!doesFileExists(PATH_MANAGERS))
		writeFile(PATH_MANAGERS, "Username,Identity,Password,Phone\n");
	if (!doesFileExists(PATH_CATALOG))
		writeFile(PATH_CATALOG, "Name,Company,Price,Quantity,Category\n");
}
char* readUser(char* filename, char* id, FieldUser field) {
	char nameString[100], ID[20], password[100], phoneString[20];
	FILE* file;
	file = fopen(filename, "r");
	if (!file) {
		printStrLine("Error.");
		return;
	}

	char buf[500];
	while (fscanf(file, "%s", buf) == 1) {
		sscanf(buf, "%[^,],%[^,],%[^,],%[^,]", nameString, ID, password, nameString, phoneString);
		if (strcmp(ID, id) == 0) {
			if (field == readName) return nameString;
			if (field == readId) return ID;
			if (field == readPassword) return password;
			if (field == readPhone) return phoneString;
		}
	}
	return NULL;
}
bool doesFileExists(char* filename) {
	struct stat buffer;
	return !stat(filename, &buffer);
}
FILE* openFile(char* filename, char* access, char* skipFormat) { // skips the first line? not yet implemented correctly
	FILE* file;
	file = fopen(filename, access);
	if (!file) {
		printStrLine("Error.");
		return;
	}
	if (skipFormat)
		fprintf(file, skipFormat);
	return file;
}

// Authentication functions definitions
void registerCustomer(Customer* c)
{
	printf("\nRegister Stage:\n");
	while (!verifyName(&(c->details)))
	{
		printf("Invalid, Please try again!\n\n");
	}

	while (!verifyPassword(&(c->details)))
	{
		printf("Invalid, Please try again!\n\n");
	}

	bool flag = false;
	while (!verifyId(&(c->details), &flag, customer))
	{
		if (flag) {
			printf("ID already exist in the system.\n");
			int choice = 1;
			printf("\nAvailable actions:\n'1' Wrong ID try again\n'2' Try to login\n'3' Reported for Identity steal\n\nYour choice --> ");
			scanf_s("%d", &choice);
			switch (choice)
			{
			case 1:
				break;
			case 2:
				loginUser();
				return;
			case 3:
				printf("We are sry to hear, Your report will be treated\n");
				return;
			default:
				printf("Invalid input, Try again\n");
				break;
			}
		}
		printf("Invalid, Please try again!\n\n");
	}

	if (!verifyAge(c))
	{
		return false;
	}

	while (!verifyPhone(&(c->details)))
	{
		printf("Invalid, Please try again!\n\n");
	}

	if (!TermsAndConditions())
		return;
	
	writeCustomer(c);
}
void registerManager(Manager* m)
{
	printf("\nRegister Stage:\n");
	while (!verifyName(&(m->details)))
	{
		printf("Invalid, Please try again!\n\n");
	}

	while (!verifyPassword(&(m->details)))
	{
		printf("Invalid, Please try again!\n\n");
	}

	bool flag = false;
	while (!verifyId(&(m->details), &flag, manager))
	{
		if (flag) {
			printf("ID already exist in the system.\n");
			int choice = 1;
			printf("\nAvailable actions:\n'1' Wrong ID try again\n'2' Try to login\n'3' Reported for Identity steal\n\nYour choice --> ");
			scanf_s("%d", &choice);
			switch (choice)
			{
			case 1:
				break;
			case 2:
				loginUser();
				return;
			case 3:
				printf("We are sry to hear, Your report will be treated\n");
				return;
			default:
				printf("Invalid input, Try again\n");
				break;
			}
		}
		printf("Invalid, Please try again!\n\n");
	}

	while (!verifyPhone(&(m->details)))
	{
		printf("Invalid, Please try again!\n\n");
	}

	if (!TermsAndConditions())
		return;

	writeManager(m);
}
bool verifyName(Details* d)
{
	char string[100];
	printf("Name --> ");
	scanf(" %[^\n]s", string);

	for (int i = 0; i < strlen(string); i++)
		if (!((string[i] >= 'a' && string[i] <= 'z') || (string[i] >= 'A' && string[i] <= 'Z') || (string[i] == ' ')))
		{
			printf("Must contain only English characters!\n");
			return false;
		}
	
	char* str = copyString(string);
	d->name = str;

	return true;
}
bool verifyPassword(Details* d)
{
	char* str;
	printf("Password --> ");
	inputString(&str);
	int letters = 0;
	int numbers = 0;
	if (strlen(str) < MIN_PASSWORD_LEN)
		return false;
	for (int i = 0; i < strlen(str); i++)
	{
		if (!(str[i] >= 'a' && str[i] <= 'z')) {
			if (!(str[i] >= 'A' && str[i] <= 'Z')) {
				if (!(str[i] >= '0' && str[i] <= '9'))
					return false;
				else numbers++;
			}
			else letters++;
		}
		else letters++;
	}

	if (!numbers)
		printf("Password must contain at least one number");
	if (!letters)
		printf("Password must contain at least one letter");
	if (letters && numbers) {
		d->password = str;
		return true;
	}
	return false;
}
bool verifyId(Details* d, bool* flag, int regType)
{
	char* str;
	printf("ID --> ");
	inputString(&str);

	long idVal = strtol(str, NULL, 10);
	int Digit1, Digit2, Digit3, Digit4, Digit5, Digit6, Digit7, Digit8, Digit9, Sum, Res; // Our Variables //

	if ((idVal <= 999999999) && (idVal >= 100000000)) // Checking if the user have entered a legal ID (8/9 digits) //
	{
		Digit1 = (idVal % 1000000000) / 100000000;   //  Most Left  //
		Digit2 = (idVal % 100000000) / 10000000;	 //             //
		Digit3 = (idVal % 10000000) / 1000000;       //   (Turning  //
		Digit4 = (idVal % 1000000) / 100000;         //   every     //
		Digit5 = (idVal % 100000) / 10000;           //   digit to  //
		Digit6 = (idVal % 10000) / 1000;             //   1 unit)   //
		Digit7 = (idVal % 1000) / 100;               //             //
		Digit8 = (idVal % 100) / 10;                 // Most Right  //
		Digit9 = (idVal % 10);                       // Digit check //

		Digit1 = Digit1 * 1;					//    Imply   //
		Digit2 = Digit2 * 2;					//            //
		Digit3 = Digit3 * 1;					//            //
		Digit4 = Digit4 * 2;					//     the    //
		Digit5 = Digit5 * 1;					//            //
		Digit6 = Digit6 * 2;					//            //
		Digit7 = Digit7 * 1;					//  Algoritm  //
		Digit8 = Digit8 * 2;					//            //

		Digit2 = ((Digit2 / 10) + (Digit2 % 10));	//  Getting a     //
		Digit4 = ((Digit4 / 10) + (Digit4 % 10));	//  tens number   //
		Digit6 = ((Digit6 / 10) + (Digit6 % 10));	//  into a one    //
		Digit8 = ((Digit8 / 10) + (Digit8 % 10));	//  singular unit //

		Sum = Digit1 + Digit2 + Digit3 + Digit4 + Digit5 + Digit6 + Digit7 + Digit8;  // The Sum of the ID according to the algoritm //

		Res = 10 - (Sum % 10); // Getting the right last digit according to the algoritm //

		if (Res == Digit9) {// Incase the last digit is correct //
			if (findUserType(str))  // in case the user already exists
			{
				*flag = true;
				return false;
			}

			d->id = str;
			return true; // True//
		}

		else if (Res != Digit9) // Incase the last digit is incorrect //
		{
			return false; // False //
		}
	}

	else // Incase the user did not have entered a legal ID formula //
	{
		return false; // False //
	}
}
bool verifyAge(Customer* c)
{
	int age;
	char string[20];

	printf("Age --> ");
	scanf_s("%d", &age);

	if (age < LEGAL_AGE)
	{
		printf("We are sry, The minimum age is 16\n");
		return false;
	}

	_itoa(age, string, 10);
	char* str = copyString(string);
	c->age = str;
	return true;
}
bool verifyPhone(Details* d)
{
	char* str;
	printf("Phone --> ");
	inputString(&str);
	if (str == NULL)
		exit(1);

	for (int i = 0; i < strlen(str); i++)
	{
		if (!(str[i] >= '0' && str[i] <= '9'))
		{
			printf("Phone number contain only Digits!\n");
			return false;
		}
	}

	if (strlen(str) != PHONE_NUM_LEN)
	{
		printf("Phone number must contain ten Digits!\n");
		return false;
	}

	d->phone = str;
	return true;
}
bool TermsAndConditions()
{
	char terms;
	printf("Do you agree to the terms and conditions (Y/N)\nInput --> ");
	getchar();
	scanf("%c", &terms);
	while (terms != 'Y' || terms != 'N')
	{
		if (terms == 'Y')
			return true;
		else if (terms == 'N')
			return false;
		else
		{
			printf("Invalid input, Try again\nInput --> ");
			getchar();
			scanf("%c", &terms);
		}
	}
}
UserType findUserType(char* id) {
	char* ID = readUser(PATH_CUSTOMERS, id, readId);
	
	if (ID)
		return customer;
	
	ID = readUser(PATH_MANAGERS, id, readId);
	if (ID)
		return manager;
	
	return none;
}
UserType loginUser() {
	char* id;
	
	printf("ID --> ");
	inputString(&id);
	
	UserType type = findUserType(id);
	if (!type) {
		printStrLine("The entered ID wasn't found...\n");
		return none;
	}

	char* pass;
	printf("Password --> ");
	inputString(&pass);

	if (strcmp(readUser(type == customer ? PATH_CUSTOMERS : PATH_MANAGERS, id, readPassword), pass) == 0) {
		printStr("You've successfully logged in as a ");
		if (type == customer)
		{
			printStr("customer.\n");
			return customer;
		}
		
		if (type == manager)
		{
			printStr("manager.\n");
			return manager;
		}
	}
	
	else 
	{
		printStrLine("The entered password is incorrect...\n");
		return none;
	}
}

//Menu's
void welcomeScreen();
void customerMenu();
void managerMenu();

// Catalog
void addProduct() 
{	
	char* rProductName = NULL;
	while (!rProductName)
	{
		printStr("Input product name --> ");
		inputString(&rProductName);

		for (int i = 0; i < strlen(rProductName); i++)
		{
			if (!(rProductName[i] >= 'a' && rProductName[i] <= 'z' || rProductName[i] >= 'A' && rProductName[i] <= 'Z')) 
			{
				rProductName = NULL;
				printStrLine("Invalid product name, Try again\n");
				break;
			}
		}
	}
	
	char* rProductCompany = NULL;
	while (!rProductCompany) 
	{
		printStr("Input company product --> ");
		inputString(&rProductCompany);

		if (doesProductExist(PATH_CATALOG, rProductName, rProductCompany)) 
		{
				printStrLine("Company product already in stock.");
				return;
		}

		for (int i = 0; i < strlen(rProductCompany); i++) 
		{
			if (!(rProductCompany[i] >= 'a' && rProductCompany[i] <= 'z' || rProductCompany[i] >= 'A' && rProductCompany[i] <= 'Z')) 
			{
				rProductCompany = NULL;
				printStrLine("Invlaid company product, Try again\n");
				break;
			}
		}
	}
	
	char* rProductPrice = NULL;
	while (!rProductPrice)
	{
		printStr("Input product price --> ");
		inputString(&rProductPrice);
		
		for (int i = 0; i < strlen(rProductPrice); i++)
		{
			if (strlen(rProductPrice) == 1 && rProductPrice[i] == '0')
			{
				rProductPrice = NULL;
				printStrLine("Invalid product price, Try again\n");
				break;
			}
			

			if (!(rProductPrice[i] >= '0' && rProductPrice[i] <= '9') && rProductPrice[i] != '.')
			{
				rProductPrice = NULL;
				printStrLine("Invalid prudct price, Try again\n");
				break;
			}
		}
	}

	char* rProductQuantity = NULL;
	while (!rProductQuantity) 
	{
		printStr("Input product quantity --> ");
		inputString(&rProductQuantity);
		
		for (int i = 0; i < strlen(rProductQuantity); i++)
		{
			if (!(rProductQuantity[i] >= '0' && rProductQuantity[i] <= '9'))
			{
				rProductQuantity = NULL;
				printStrLine("Invalid quantity, Try again\n");
				break;
			}
		}
	}

	/* NEED TO FINISH THE CATEGORY PART!!	
	char* rProductCategory = NULL;
	while (!rProductCategory)
	{
		printStr("Input product category --> ");
		inputString(&rProductCategory);

		for (int i = 0; i < strlen(rProductCategory); i++)
		{
			if (!(rProductCategory[i] >= 'a' && rProductCategory[i] <= 'z' || rProductCategory[i] >= 'A' && rProductCategory[i] <= 'Z'))
			{
				rProductCategory = NULL;
				printStrLine("Invlaid company product");
				break;
			}
		}

		if (doesCategoryExist(PATH_CATALOG, rProductName, rProductCompany))
		{
			printStrLine("Company product already in stock.");
			return;
		}
	}*/

	char* output = copyString("");
	appendStringComma(&output, rProductName);
	appendStringComma(&output, rProductCompany);
	appendStringComma(&output, rProductPrice);
	appendStringNewLine(&output, rProductQuantity);
	//appendStringNewLine(&output, rProductCategory);
	writeFile(PATH_CATALOG, output);
	free(output);
}
bool doesProductExist(char* filename, char* _productName, char* _company) 
{
	char name[100], company[100], price[20], quantity[100], category[100];

	FILE* file;
	file = fopen(filename, "r");
	if (!file) {
		printStrLine("Error.");
		return;
	}

	char buf[500];
	while (fscanf(file, "%s", buf) == 1)
	{
		sscanf(buf, "%[^,],%[^,],%[^,],%[^,],%[^,]", name, company, price, quantity, category);

		if (strcmp(_productName, name) == 0 && strcmp(_company, company) == 0)
			return true;
	}
	return false;
}
char* readProduct(char* filename, char* _productName, char* _company, FieldProduct field) {
	char name[100], company[100], price[20], quantity[100], category[100];
	
	FILE* file;
	file = fopen(filename, "r");
	if (!file) {
		printStrLine("Error.");
		return;
	}

	char buf[500];
	while (fscanf(file, "%s", buf) == 1) 
	{
		sscanf(buf, "%[^,],%[^,],%[^,],%[^,],%[^,]", name, company, price, quantity, category);

		if (strcmp(_productName, name) == 0 && strcmp(_company, company) == 0)
		{
			if (field == productName) return name;
			if (field == productCompany) return company;
			if (field == productPrice) return price;
			if (field == productQuantity) return quantity;
			if (field == productCategory) return category;
		}
	}
	return NULL;
}

// Menu's
void welcomeScreen() {
	Customer c;
	Manager m;
	
	int loop = 1, regLog = 1, regType = 1, managerCode;

	printf("Welcome to \"Market for you\"\n'1' Register\n'2' Log in\n'3' Exit\nInput --> ");
	scanf_s("%d", &regLog);
	
	while (loop)
	{
		switch (regLog)
		{
		case 1:
			printf("\nSign up as\n'1' Customer\n'2' Manager\n'3' Exit\nInput --> ");
			scanf_s("%d", &regType);

			switch (regType)
			{
			case 1:
				registerCustomer(&c);
				break;

			case 2:
				printf("Input manager code --> ");
				scanf_s("%d", &managerCode);
				
				if (MANAGER_CODE == managerCode)
					registerManager(&m);
				
				else
					printf("Wrong Code\n");
				break;

			case 3:
				break;

			default:
				printf("Error input, Try again!\n\nInput --> ");
				scanf("%d", &regType);
				break;

			}
			break;

		case 2:
			if (loginUser() == customer)
				customerMenu();

			else if (loginUser() == manager)
				managerMenu();

			else
				printf("Failed login\n");
			break;

		case 3:
			loop = 0;
			break;

		default:
			printf("Invalid input, Try again!\n\nInput --> ");
			scanf_s("%d", &regLog);
			break;

		}
	}
}
void customerMenu()
{

}
void managerMenu()
{

}
Product selectProduct() {
	Product product = { NULL, NULL, NULL, NULL };
	char name[100], company[100], quantity[100], price[100];

	FILE* file;
	file = fopen(PATH_CATALOG, "r");
	if (!file) {
		printStrLine("Error.");
		return;
	}

	char buf[500];
	int i = 1;
	printf("\tNAME\t\tCOMPANY\t\tQUANTITY\t\tPRICE\n");
	while (fscanf(file, "%s", buf) == 1) {
		sscanf(buf, "%[^,],%[^,],%[^,],%[^,]", name, company, quantity, price);
		printf("%d.\t%s\t\t%s\t\t%s\t\t\t%s\n", i, name, company, quantity, price);
		i++;
	}
	printStr("Please select a product --> ");

	int res;
	scanf("%d", &res);

	// retrieve the selected product
	int j = 1;
	file = fopen(PATH_CATALOG, "r");
	while (fscanf(file, "%s", buf) == 1 && j <= i) {
		if (j != res) {
			sscanf(buf, "%*s,*s,%*s,%*s");
			j++;
		}
		else {
			sscanf(buf, "%[^,],%[^,],%[^,],%[^,]", name, company, quantity, price);
			product.name = copyString(name);
			product.company = copyString(company);
			product.quantity = copyString(quantity);
			product.price = copyString(price);
			return product;
		}
	}
	return product;
}

void printProduct(Product* product) {
	printf("Name %s\tCompany %s\tPrice %s\tQuantity %s", product->name, product->company, product->price, product->quantity);
}

int main() {
	checkFolder();
	checkFiles();
	addProduct();
	//welcomeScreen();
	return 0;
}
